# Phase 1.5: Automatic Speech Flow System - Research

**Researched:** 2026-01-23
**Domain:** Automatic speech parsing, Character Bible integration, Livewire reactive patterns
**Confidence:** HIGH

## Summary

This phase removes manual Character Intelligence configuration and replaces it with an automatic speech flow system. The core challenge is **automatic parsing** (script text ‚Üí speech segments), **automatic linking** (segment speakers ‚Üí Character Bible entries), and **seamless data flow** (segments ‚Üí scenes ‚Üí shots ‚Üí video generation) without user intervention.

The existing codebase already has `SpeechSegmentParser` and `SpeechSegment` classes from a prior implementation (Phases 1-7 of Dynamic Speech Segments). This phase focuses on **triggering parsing automatically** and **removing/replacing the UI**, not building the parser from scratch.

**Primary recommendation:** Use Livewire reactive properties with debounced listeners to trigger parsing automatically on script changes. Implement fuzzy name matching for Character Bible linking. Replace the Character Intelligence UI section with a read-only "Detection Summary" panel.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Laravel Livewire | 3.x | Reactive component system | Already in use, provides wire:model.blur for auto-save patterns |
| PHP Native | 8.x | Text parsing with preg_match | Built-in regex support, no dependencies needed |
| Eloquent Observers | Laravel 11.x | Model event listeners | Native Laravel pattern for automatic updates |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Levenshtein Distance | PHP Native | Fuzzy name matching | Character Bible auto-linking by speaker name |
| similar_text() | PHP Native | String similarity | Fallback for name matching |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Native fuzzy matching | wyndow/fuzzywuzzy | External library adds dependency, but provides Jaro-Winkler for better name matching |
| Livewire events | Alpine.js events | More frontend control, but less server-side integration |
| Model observers | Manual triggers | More control, but requires explicit calls everywhere |

**Installation:**
No new packages required - existing stack sufficient. Optional: `composer require wyndow/fuzzywuzzy` for advanced name matching.

## Architecture Patterns

### Recommended Data Flow Structure
```
Script Generation/Edit
    ‚Üì
Auto-parse (SpeechSegmentParser)
    ‚Üì
Auto-link speakers ‚Üí Character Bible
    ‚Üì
Segments flow to scenes array
    ‚Üì
Scenes flow to shots
    ‚Üì
Video generation reads segments
```

### Pattern 1: Livewire Auto-Parse on Script Change
**What:** Wire script textarea with `wire:model.blur` to trigger parsing when user clicks away
**When to use:** Manual script editing by user
**Example:**
```php
// In Blade template (concept.blade.php)
<textarea wire:model.blur="script.text"></textarea>

// In VideoWizard.php
public function updated($propertyName)
{
    if ($propertyName === 'script.text') {
        $this->parseScriptIntoSegments();
    }
}

protected function parseScriptIntoSegments()
{
    $parser = new SpeechSegmentParser();
    $characterBible = $this->sceneMemory['characterBible'] ?? [];

    $segments = $parser->parse($this->script['text'], $characterBible);

    // Auto-link speakers to Character Bible
    $this->autoLinkSegmentsToCharacterBible($segments);

    // Store segments in script data
    $this->script['speechSegments'] = $segments;
}
```

### Pattern 2: Auto-Parse After AI Script Generation
**What:** Hook into ScriptGenerationService to parse immediately after AI generates script
**When to use:** AI-generated scripts
**Example:**
```php
// In ScriptGenerationService.php
public function generateScript(WizardProject $project, array $options = []): array
{
    // ... existing AI generation code ...

    $script = $result['script'];

    // Auto-parse script into segments
    $parser = new SpeechSegmentParser();
    $characterBible = $options['characterBible'] ?? [];

    foreach ($script['scenes'] as &$scene) {
        if (!empty($scene['narration'])) {
            $segments = $parser->parse($scene['narration'], $characterBible);
            $scene['speechSegments'] = $parser->toArray($segments);
        }
    }

    return $script;
}
```

### Pattern 3: Auto-Create Character Bible Entries
**What:** When parser detects new speaker not in Character Bible, auto-create entry
**When to use:** After parsing, before linking
**Example:**
```php
protected function autoLinkSegmentsToCharacterBible(array $segments)
{
    $characterBible = &$this->sceneMemory['characterBible']['characters'];

    foreach ($segments as $segment) {
        if (!$segment->hasSpeaker()) {
            continue; // Narrator segments skip
        }

        // Find matching character by name (fuzzy)
        $matchedCharId = $this->findCharacterByName($segment->speaker, $characterBible);

        if ($matchedCharId) {
            // Link to existing
            $segment->characterId = $matchedCharId;
            $segment->voiceId = $this->getCharacterVoiceId($matchedCharId);
        } else {
            // Auto-create new Character Bible entry
            $newCharId = 'char_' . time() . '_' . Str::random(4);
            $characterBible[] = [
                'id' => $newCharId,
                'name' => $segment->speaker,
                'description' => '',
                'scenes' => [],
                'voiceId' => null, // User can assign later
                'autoDetected' => true,
            ];
            $segment->characterId = $newCharId;
        }
    }
}
```

### Pattern 4: Fuzzy Name Matching
**What:** Match speaker names to Character Bible entries using case-insensitive partial matching
**When to use:** Auto-linking speakers
**Example:**
```php
protected function findCharacterByName(string $speaker, array $characterBible): ?string
{
    $speakerUpper = strtoupper(trim($speaker));

    foreach ($characterBible as $char) {
        $charName = strtoupper(trim($char['name'] ?? ''));

        // Exact match
        if ($charName === $speakerUpper) {
            return $char['id'];
        }

        // Partial match (contains)
        if (str_contains($charName, $speakerUpper) || str_contains($speakerUpper, $charName)) {
            return $char['id'];
        }

        // Fuzzy match with Levenshtein (optional)
        $distance = levenshtein($speakerUpper, $charName);
        if ($distance <= 2) { // Allow 2-character difference
            return $char['id'];
        }
    }

    return null;
}
```

### Anti-Patterns to Avoid
- **Parsing on every keystroke:** Use `wire:model.blur` not `wire:model.live` to avoid excessive server requests
- **Overwriting user edits:** Check if segments already exist before auto-parsing to preserve manual edits
- **Ignoring Character Bible updates:** When Character Bible changes (new voice assigned), re-link segments
- **Blocking UI during parse:** Parsing should be background, non-blocking with loading states

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Script parsing regex | Custom tokenizer | Existing `SpeechSegmentParser` | Already handles [NARRATOR], CHARACTER:, etc. formats |
| Name matching | Simple string compare | Levenshtein distance or similar_text() | Handles typos, case variations |
| Auto-save debounce | JavaScript setTimeout | `wire:model.blur` or `.debounce` | Livewire handles it natively |
| Change detection | Manual dirty flags | Livewire `updated()` hook | Framework handles property tracking |
| Backward compatibility | Migration script | Legacy check in parser | `migrateFromLegacy()` method exists |

**Key insight:** The parsing infrastructure already exists from the prior Dynamic Speech Segments implementation. Don't rebuild - integrate the existing parser into automatic triggers.

## Common Pitfalls

### Pitfall 1: Infinite Re-Parse Loops
**What goes wrong:** Parsing triggers a property update, which triggers another parse, creating an infinite loop
**Why it happens:** Livewire `updated()` hook fires when ANY property changes, including the segments you just created
**How to avoid:** Use a flag to prevent re-entry
**Warning signs:** Browser hangs, console shows repeated parse logs
```php
protected $isParsing = false;

public function updated($propertyName)
{
    if ($this->isParsing) return;

    if ($propertyName === 'script.text') {
        $this->isParsing = true;
        $this->parseScriptIntoSegments();
        $this->isParsing = false;
    }
}
```

### Pitfall 2: Character Bible Out of Sync
**What goes wrong:** Segments reference characterId that no longer exists in Character Bible
**Why it happens:** User deletes character, but segments still have old ID
**How to avoid:** Add validation/cleanup when Character Bible changes
**Warning signs:** Missing voice settings, broken character links
```php
public function deleteCharacter($characterId)
{
    // Remove from Character Bible
    $this->sceneMemory['characterBible']['characters'] = array_filter(
        $this->sceneMemory['characterBible']['characters'],
        fn($c) => $c['id'] !== $characterId
    );

    // Clean up segment references
    foreach ($this->script['scenes'] as &$scene) {
        foreach ($scene['speechSegments'] ?? [] as &$segment) {
            if ($segment['characterId'] === $characterId) {
                $segment['characterId'] = null;
                $segment['voiceId'] = null;
            }
        }
    }
}
```

### Pitfall 3: Debounce Too Aggressive
**What goes wrong:** User types fast, debounce delay too long, parsing lags behind editing
**Why it happens:** Default Livewire debounce is 150ms, but for manual editing blur is better
**How to avoid:** Use `wire:model.blur` instead of `.live.debounce` for manual text editing
**Warning signs:** Segments don't update after user finishes typing

### Pitfall 4: Backward Compatibility Breaking
**What goes wrong:** Old projects with `characterIntelligence` property fail to load
**Why it happens:** Removed property without migration path
**How to avoid:** Keep deprecated property, check on load and migrate
**Warning signs:** Existing projects error on load
```php
public function mount()
{
    // Migrate old characterIntelligence to new system
    if (isset($this->characterIntelligence) && !isset($this->script['speechSegments'])) {
        $this->migrateCharacterIntelligence();
    }
}

protected function migrateCharacterIntelligence()
{
    // Convert old narrationStyle to segment-based approach
    if ($this->characterIntelligence['enabled'] ?? false) {
        // Parse existing voiceover text into segments
        // Set speechType = 'mixed' to indicate new system
    }
}
```

### Pitfall 5: UI Race Condition
**What goes wrong:** User opens Character Bible modal while parsing is running, sees old data
**Why it happens:** Async parsing hasn't finished when modal opens
**How to avoid:** Show loading state, disable modal until parsing complete
**Warning signs:** Modal shows empty or outdated character list

## Code Examples

Verified patterns from existing codebase:

### Auto-Parse on Script Generation (Integration Point)
```php
// Source: ScriptGenerationService.php (existing)
// Add this after AI script generation completes

public function generateScript(WizardProject $project, array $options = []): array
{
    // ... existing generation code ...

    // AUTO-PARSE INTEGRATION
    $parser = new SpeechSegmentParser();
    $characterBible = $options['characterBible'] ?? [];

    foreach ($result['script']['scenes'] as $idx => &$scene) {
        if (!empty($scene['narration'])) {
            $segments = $parser->parse($scene['narration'], $characterBible);

            // Store as array for JSON serialization
            $scene['speechSegments'] = $parser->toArray($segments);

            // Set speechType = 'mixed' to indicate segment-based system
            $scene['speechType'] = 'mixed';
        }
    }

    return $result;
}
```

### Auto-Parse on Manual Edit (Livewire Component)
```php
// Source: VideoWizard.php (to be added)

protected $isParsing = false;

public function updated($propertyName)
{
    // Auto-parse script when narration text changes
    if (str_starts_with($propertyName, 'script.scenes.') && str_ends_with($propertyName, '.narration')) {
        $this->parseSceneNarration($propertyName);
    }
}

protected function parseSceneNarration(string $propertyPath)
{
    if ($this->isParsing) return;

    $this->isParsing = true;

    // Extract scene index from property path: 'script.scenes.0.narration' -> 0
    preg_match('/script\.scenes\.(\d+)\.narration/', $propertyPath, $matches);
    $sceneIndex = (int)($matches[1] ?? 0);

    if (!isset($this->script['scenes'][$sceneIndex])) {
        $this->isParsing = false;
        return;
    }

    $scene = &$this->script['scenes'][$sceneIndex];
    $parser = new SpeechSegmentParser();
    $characterBible = $this->sceneMemory['characterBible'] ?? [];

    // Parse narration text into segments
    $segments = $parser->parse($scene['narration'] ?? '', $characterBible);

    // Auto-link to Character Bible and create missing entries
    $this->autoLinkAndCreateCharacters($segments);

    // Store segments
    $scene['speechSegments'] = $parser->toArray($segments);
    $scene['speechType'] = 'mixed';

    $this->isParsing = false;
}

protected function autoLinkAndCreateCharacters(array $segments)
{
    $characterBible = &$this->sceneMemory['characterBible']['characters'];

    foreach ($segments as $segment) {
        if (!$segment->hasSpeaker()) continue;

        // Try to match to existing character
        $matchedId = $this->findCharacterByName($segment->speaker, $characterBible);

        if ($matchedId) {
            $segment->characterId = $matchedId;
            $segment->voiceId = $this->getCharacterVoiceId($matchedId);
        } else {
            // Auto-create Character Bible entry
            $newCharId = 'char_' . time() . '_' . Str::random(4);
            $characterBible[] = [
                'id' => $newCharId,
                'name' => $segment->speaker,
                'description' => '',
                'scenes' => [],
                'voiceId' => null,
                'autoDetected' => true,
            ];
            $segment->characterId = $newCharId;
        }
    }
}

protected function findCharacterByName(string $speaker, array $characterBible): ?string
{
    $speakerUpper = strtoupper(trim($speaker));

    foreach ($characterBible as $char) {
        $charName = strtoupper(trim($char['name'] ?? ''));

        // Exact match
        if ($charName === $speakerUpper) {
            return $char['id'];
        }

        // Partial match
        if (str_contains($charName, $speakerUpper) || str_contains($speakerUpper, $charName)) {
            return $char['id'];
        }

        // Fuzzy match (Levenshtein distance)
        $distance = levenshtein($speakerUpper, $charName);
        if ($distance <= 2) {
            return $char['id'];
        }
    }

    return null;
}

protected function getCharacterVoiceId(string $characterId): ?string
{
    $characterBible = $this->sceneMemory['characterBible']['characters'] ?? [];

    foreach ($characterBible as $char) {
        if ($char['id'] === $characterId) {
            return $char['voiceId'] ?? null;
        }
    }

    return null;
}
```

### Detection Summary Panel (Replacement UI)
```php
// Source: New component for concept.blade.php

{{-- Replace Character Intelligence section with Detection Summary --}}
<div class="vw-detection-summary-card" x-data="{ expanded: false }">
    <div class="vw-summary-header" @click="expanded = !expanded">
        <div class="vw-summary-left">
            <div class="vw-summary-icon">üîç</div>
            <div>
                <h3 class="vw-summary-title">{{ __('Detection Summary') }}</h3>
                <p class="vw-summary-subtitle">{{ __('Auto-detected from script') }}</p>
            </div>
        </div>
        <button type="button" class="vw-expand-btn">
            <span x-show="!expanded">‚ñº</span>
            <span x-show="expanded">‚ñ≤</span>
        </button>
    </div>

    <div x-show="expanded" x-collapse>
        <div class="vw-summary-content">
            {{-- Characters Detected --}}
            @if(!empty($detectionSummary['characters']))
                <div class="vw-summary-section">
                    <h4>{{ __('Characters Detected') }}</h4>
                    <div class="vw-character-chips">
                        @foreach($detectionSummary['characters'] as $char)
                            <span class="vw-chip">
                                {{ $char['name'] }}
                                @if(!empty($char['voiceId']))
                                    <span class="vw-chip-badge">‚úì</span>
                                @endif
                            </span>
                        @endforeach
                    </div>
                    <a href="#" wire:click.prevent="openCharacterBible" class="vw-link">
                        ‚Üí {{ __('Edit in Character Bible') }}
                    </a>
                </div>
            @endif

            {{-- Speech Types Found --}}
            @if(!empty($detectionSummary['speechTypes']))
                <div class="vw-summary-section">
                    <h4>{{ __('Speech Types Found') }}</h4>
                    <div class="vw-stats-row">
                        @foreach($detectionSummary['speechTypes'] as $type => $count)
                            <div class="vw-stat">
                                <span class="vw-stat-icon">{{ $this->getSpeechTypeIcon($type) }}</span>
                                <span class="vw-stat-label">{{ ucfirst($type) }}</span>
                                <span class="vw-stat-value">{{ $count }}</span>
                            </div>
                        @endforeach
                    </div>
                </div>
            @endif
        </div>
    </div>
</div>
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Manual Character Intelligence UI | Auto-parse + Detection Summary | Phase 1.5 (2026-01) | No manual configuration needed |
| Single narration style dropdown | Segment-based mixed speech types | Phase 1-7 (prior) | Scenes can have multiple speech types |
| Manual speaker assignment | Auto-link by name matching | Phase 1.5 (2026-01) | Character Bible auto-populated |
| `speechType` field | `speechType = 'mixed'` + `speechSegments` array | Phase 1.5 (2026-01) | Segment-based system indicator |
| wire:model.defer | wire:model.blur | Livewire v3 (2023) | Better UX for auto-save |

**Deprecated/outdated:**
- `characterIntelligence` property: Replaced with automatic parsing, keep for backward compatibility
- `narrationStyle` dropdown: Replaced with Detection Summary panel
- `characterCount` slider: No longer needed, auto-detected from segments

## Open Questions

Things that couldn't be fully resolved:

1. **Debounce timing for manual edits**
   - What we know: Livewire default is 150ms, blur waits until focus loss
   - What's unclear: Whether users prefer instant parse (blur) or delayed parse (debounce) for manual editing
   - Recommendation: Use `wire:model.blur` for simplicity, add debounce only if users report performance issues

2. **Edge case: No speakers detected**
   - What we know: Parser returns narrator segments when no speakers found
   - What's unclear: Whether to show warning or silently accept narrator-only content
   - Recommendation: Accept silently, show in Detection Summary (0 characters detected)

3. **Edge case: Unknown speaker names**
   - What we know: Auto-create Character Bible entry works
   - What's unclear: Should we highlight "unverified" auto-created characters vs. user-created?
   - Recommendation: Add `autoDetected: true` flag, show badge in Character Bible UI

4. **Performance with large scripts**
   - What we know: Parser can handle 50 segments per scene (limit defined)
   - What's unclear: Parse time for 20+ scenes with multiple segments each
   - Recommendation: Test with large scripts, add loading indicator if parse > 500ms

## Sources

### Primary (HIGH confidence)
- Livewire 3.x wire:model documentation - https://livewire.laravel.com/docs/3.x/wire-model
- Laravel Eloquent observers guide - https://laravel.com/docs/11.x/eloquent
- Existing SpeechSegmentParser.php implementation (verified in codebase)
- Existing SpeechSegment.php data class (verified in codebase)

### Secondary (MEDIUM confidence)
- Livewire reactive properties - https://livewire.laravel.com/docs/4.x/attribute-reactive
- Laravel Model Events guide - https://medium.com/@developerawam/laravel-model-events-run-automatic-actions-when-data-is-created-updated-or-deleted-86d0e768caa4
- Livewire auto-save patterns - https://laravel-news.com/livewire-wire-model-live
- PHP fuzzy string matching - https://dev.to/edgaras/efficiently-measure-string-similarity-in-php-applications-l31

### Tertiary (LOW confidence)
- Fuzzy matching algorithms overview - https://matchdatapro.com/fuzzy-matching-101-a-complete-guide-for-2026/
- Laravel queue debouncing - https://github.com/mpbarlow/laravel-queue-debouncer

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Livewire/Laravel native features, verified in codebase
- Architecture: HIGH - Existing parser classes confirmed, integration patterns standard
- Pitfalls: HIGH - Based on Livewire documentation and common reactive pitfalls

**Research date:** 2026-01-23
**Valid until:** 30 days (stable Laravel/Livewire ecosystem)
