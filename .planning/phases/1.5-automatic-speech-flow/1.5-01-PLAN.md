---
phase: 1.5-automatic-speech-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - modules/AppVideoWizard/app/Livewire/VideoWizard.php
  - modules/AppVideoWizard/app/Services/ScriptGenerationService.php
autonomous: true

must_haves:
  truths:
    - "Script is auto-parsed into speech segments immediately after AI generation"
    - "Each scene has speechSegments array populated with parsed segments"
    - "Segments have correct type (narrator, dialogue, internal, monologue)"
    - "Segments with speakers have characterId linked to Character Bible"
  artifacts:
    - path: "modules/AppVideoWizard/app/Livewire/VideoWizard.php"
      provides: "Auto-parse trigger after script generation + auto-link speakers"
      contains: "parseScriptIntoSegments"
    - path: "modules/AppVideoWizard/app/Services/ScriptGenerationService.php"
      provides: "Integration point for auto-parsing"
      contains: "SpeechSegmentParser"
  key_links:
    - from: "VideoWizard::generateScript"
      to: "parseScriptIntoSegments"
      via: "method call after script generation"
      pattern: "parseScriptIntoSegments"
    - from: "parseScriptIntoSegments"
      to: "SpeechSegmentParser::parse"
      via: "service call"
      pattern: "parser->parse"
---

<objective>
Add automatic speech segment parsing after AI script generation.

Purpose: When AI generates a script, it should be automatically parsed into speech segments and speakers should be auto-linked to Character Bible entries. This removes the need for manual parsing triggers.

Output: Script generation automatically produces parsed speechSegments with characterId links.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/1.5-automatic-speech-flow/1.5-CONTEXT.md
@.planning/phases/1.5-automatic-speech-flow/1.5-RESEARCH.md
@modules/AppVideoWizard/app/Services/SpeechSegmentParser.php
@modules/AppVideoWizard/app/Services/SpeechSegment.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add parseScriptIntoSegments method to VideoWizard</name>
  <files>modules/AppVideoWizard/app/Livewire/VideoWizard.php</files>
  <action>
Add a new protected method `parseScriptIntoSegments()` to the VideoWizard component.

Location: Add after the existing `autoDetectCharacterIntelligence()` method (around line 4928).

Implementation:
```php
/**
 * Auto-parse all scene narrations into speech segments.
 * Called automatically after script generation.
 */
protected function parseScriptIntoSegments(): void
{
    $parser = new \Modules\AppVideoWizard\Services\SpeechSegmentParser();
    $characterBible = $this->sceneMemory['characterBible'] ?? [];

    foreach ($this->script['scenes'] as $idx => &$scene) {
        $narration = $scene['narration'] ?? '';
        if (empty(trim($narration))) {
            continue;
        }

        // Parse narration into segments
        $segments = $parser->parse($narration, $characterBible);

        // Auto-link speakers to Character Bible and create missing entries
        $this->autoLinkAndCreateCharacters($segments);

        // Store as array for JSON serialization
        $scene['speechSegments'] = $parser->toArray($segments);
        $scene['speechType'] = 'mixed'; // Indicate segment-based system
    }

    Log::info('VideoWizard: Auto-parsed script into segments', [
        'project_id' => $this->projectId,
        'scene_count' => count($this->script['scenes'] ?? []),
    ]);
}
```

Also add the `autoLinkAndCreateCharacters` helper method:
```php
/**
 * Auto-link speech segments to Character Bible entries.
 * Creates new Character Bible entries for unknown speakers.
 *
 * @param SpeechSegment[] $segments
 */
protected function autoLinkAndCreateCharacters(array &$segments): void
{
    $characterBible = &$this->sceneMemory['characterBible']['characters'];
    if (!is_array($characterBible)) {
        $characterBible = [];
    }

    foreach ($segments as $segment) {
        if (!$segment->hasSpeaker()) {
            continue; // Narrator segments skip
        }

        // Find matching character by name (fuzzy)
        $matchedCharId = $this->findCharacterByNameFuzzy($segment->speaker, $characterBible);

        if ($matchedCharId) {
            // Link to existing character
            $segment->characterId = $matchedCharId;
            $segment->voiceId = $this->getCharacterVoiceIdFromBible($matchedCharId);
        } else {
            // Auto-create new Character Bible entry
            $newCharId = 'char_' . time() . '_' . \Illuminate\Support\Str::random(4);
            $characterBible[] = [
                'id' => $newCharId,
                'name' => $segment->speaker,
                'description' => '',
                'scenes' => [],
                'voiceId' => null,
                'autoDetected' => true,
            ];
            $segment->characterId = $newCharId;

            Log::info('VideoWizard: Auto-created Character Bible entry', [
                'name' => $segment->speaker,
                'characterId' => $newCharId,
            ]);
        }
    }
}

/**
 * Find character by name using fuzzy matching (case-insensitive + Levenshtein).
 */
protected function findCharacterByNameFuzzy(string $speaker, array $characterBible): ?string
{
    $speakerUpper = strtoupper(trim($speaker));

    foreach ($characterBible as $char) {
        $charName = strtoupper(trim($char['name'] ?? ''));

        // Exact match
        if ($charName === $speakerUpper) {
            return $char['id'] ?? null;
        }

        // Partial match (contains)
        if (!empty($charName) && (str_contains($charName, $speakerUpper) || str_contains($speakerUpper, $charName))) {
            return $char['id'] ?? null;
        }

        // Fuzzy match with Levenshtein (allow 2-character difference)
        if (!empty($charName) && levenshtein($speakerUpper, $charName) <= 2) {
            return $char['id'] ?? null;
        }
    }

    return null;
}

/**
 * Get voice ID for a character from Character Bible.
 */
protected function getCharacterVoiceIdFromBible(string $characterId): ?string
{
    $characterBible = $this->sceneMemory['characterBible']['characters'] ?? [];

    foreach ($characterBible as $char) {
        if (($char['id'] ?? null) === $characterId) {
            return $char['voiceId'] ?? null;
        }
    }

    return null;
}
```

Add `$isParsing` flag as a class property (around line 620, near other state flags):
```php
/**
 * Flag to prevent re-entry during parsing.
 */
protected bool $isParsing = false;
```
  </action>
  <verify>
Search for `parseScriptIntoSegments` in VideoWizard.php - method should exist.
Search for `autoLinkAndCreateCharacters` - method should exist.
Search for `findCharacterByNameFuzzy` - method should exist.
  </verify>
  <done>
VideoWizard has parseScriptIntoSegments method that:
- Uses SpeechSegmentParser to parse each scene's narration
- Auto-links speakers to Character Bible entries
- Creates new Character Bible entries for unknown speakers
- Sets speechType = 'mixed' on parsed scenes
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate auto-parse into generateScript flow</name>
  <files>modules/AppVideoWizard/app/Livewire/VideoWizard.php</files>
  <action>
Modify the `generateScript()` method to call `parseScriptIntoSegments()` after script generation.

Location: In the `generateScript()` method, around line 2970 (after `$this->recalculateVoiceStatus();`).

Add this code block:
```php
// =====================================================================
// AUTO-PARSE SCRIPT INTO SPEECH SEGMENTS (Phase 1.5)
// =====================================================================
try {
    $this->parseScriptIntoSegments();

    // Build detection summary for UI
    $this->buildDetectionSummary();

    $this->dispatch('vw-debug', [
        'action' => 'auto-parse-complete',
        'message' => 'Script auto-parsed into speech segments',
        'data' => [
            'scenes_parsed' => count($this->script['scenes'] ?? []),
        ],
    ]);
} catch (\Exception $parseEx) {
    Log::warning('VideoWizard: Auto-parse failed (non-critical)', [
        'error' => $parseEx->getMessage(),
    ]);
}
```

Also add the `buildDetectionSummary()` method (after parseScriptIntoSegments):
```php
/**
 * Build detection summary from parsed speech segments.
 * Used for the read-only Detection Summary UI panel.
 */
protected function buildDetectionSummary(): void
{
    $parser = new \Modules\AppVideoWizard\Services\SpeechSegmentParser();
    $allSegments = [];

    // Collect all segments from all scenes
    foreach ($this->script['scenes'] ?? [] as $scene) {
        $segments = $scene['speechSegments'] ?? [];
        foreach ($segments as $seg) {
            $allSegments[] = $seg;
        }
    }

    // Get statistics
    $stats = $parser->getStatistics($allSegments);

    // Build character list with voice status
    $characters = [];
    $characterBible = $this->sceneMemory['characterBible']['characters'] ?? [];

    foreach ($stats['speakers'] as $speakerName) {
        $charEntry = [
            'name' => $speakerName,
            'voiceId' => null,
            'linked' => false,
        ];

        // Find in Character Bible
        foreach ($characterBible as $char) {
            if (strtoupper(trim($char['name'] ?? '')) === strtoupper(trim($speakerName))) {
                $charEntry['voiceId'] = $char['voiceId'] ?? null;
                $charEntry['linked'] = true;
                break;
            }
        }

        $characters[] = $charEntry;
    }

    // Store detection summary
    $this->detectionSummary = [
        'characters' => $characters,
        'speechTypes' => $stats['byType'],
        'totalSegments' => $stats['total'],
        'needsLipSync' => $stats['needsLipSync'],
        'voiceoverOnly' => $stats['voiceoverOnly'],
        'estimatedDuration' => $stats['estimatedDuration'],
    ];
}
```

Add the `$detectionSummary` property near the top of the class (around line 625):
```php
/**
 * Detection summary for UI display (read-only).
 * Populated after script parsing.
 */
public array $detectionSummary = [
    'characters' => [],
    'speechTypes' => [],
    'totalSegments' => 0,
    'needsLipSync' => 0,
    'voiceoverOnly' => 0,
    'estimatedDuration' => 0,
];
```
  </action>
  <verify>
Search for `parseScriptIntoSegments` call in generateScript method.
Search for `buildDetectionSummary` method.
Search for `detectionSummary` property declaration.
  </verify>
  <done>
generateScript() method now:
- Calls parseScriptIntoSegments() after script generation
- Builds detection summary for UI display
- Dispatches debug event on completion
- Handles parse errors gracefully (non-critical)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add auto-parse on manual narration edit</name>
  <files>modules/AppVideoWizard/app/Livewire/VideoWizard.php</files>
  <action>
Modify or add to the `updated()` method to trigger parsing when scene narration changes.

Location: Find existing `updated()` method or add one if not present.

Add this logic to handle narration changes:
```php
/**
 * Handle property updates with auto-parsing for narration changes.
 */
public function updated($propertyName, $value): void
{
    // Auto-parse when scene narration changes (wire:model.blur)
    if (preg_match('/^script\.scenes\.(\d+)\.narration$/', $propertyName, $matches)) {
        if ($this->isParsing) {
            return; // Prevent re-entry
        }

        $sceneIndex = (int)$matches[1];
        $this->parseSceneNarration($sceneIndex);
    }
}

/**
 * Parse a single scene's narration into segments.
 * Called when user edits narration text (wire:model.blur).
 */
protected function parseSceneNarration(int $sceneIndex): void
{
    if ($this->isParsing) {
        return;
    }

    if (!isset($this->script['scenes'][$sceneIndex])) {
        return;
    }

    $this->isParsing = true;

    try {
        $scene = &$this->script['scenes'][$sceneIndex];
        $narration = $scene['narration'] ?? '';

        if (empty(trim($narration))) {
            $scene['speechSegments'] = [];
            $scene['speechType'] = 'narrator'; // Default for empty
            return;
        }

        $parser = new \Modules\AppVideoWizard\Services\SpeechSegmentParser();
        $characterBible = $this->sceneMemory['characterBible'] ?? [];

        // Parse narration into segments
        $segments = $parser->parse($narration, $characterBible);

        // Auto-link speakers to Character Bible
        $this->autoLinkAndCreateCharacters($segments);

        // Store segments
        $scene['speechSegments'] = $parser->toArray($segments);
        $scene['speechType'] = 'mixed';

        // Rebuild detection summary
        $this->buildDetectionSummary();

        Log::info('VideoWizard: Auto-parsed scene narration', [
            'scene_index' => $sceneIndex,
            'segment_count' => count($segments),
        ]);

    } finally {
        $this->isParsing = false;
    }
}
```

Note: If an `updated()` method already exists, merge this logic into it. Check for existing updated() method first.
  </action>
  <verify>
Search for `updated.*propertyName` in VideoWizard.php.
Search for `parseSceneNarration` method.
Check that `wire:model.blur` or `wire:model` is used for narration textareas in script.blade.php.
  </verify>
  <done>
VideoWizard now auto-parses scene narration when:
- User edits narration text and clicks away (blur)
- isParsing flag prevents infinite loops
- Detection summary is rebuilt after each parse
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Code compilation check:
   - No PHP syntax errors in modified files
   - `php artisan tinker` loads successfully

2. Method existence check:
   - `parseScriptIntoSegments` exists in VideoWizard
   - `autoLinkAndCreateCharacters` exists in VideoWizard
   - `buildDetectionSummary` exists in VideoWizard
   - `parseSceneNarration` exists in VideoWizard

3. Integration check:
   - `generateScript` calls `parseScriptIntoSegments`
   - `updated` method handles narration changes
</verification>

<success_criteria>
- [ ] parseScriptIntoSegments method added to VideoWizard
- [ ] autoLinkAndCreateCharacters method added with fuzzy name matching
- [ ] generateScript calls parseScriptIntoSegments after script generation
- [ ] buildDetectionSummary method creates summary for UI
- [ ] updated method handles script.scenes.N.narration changes
- [ ] parseSceneNarration method parses individual scene on edit
- [ ] isParsing flag prevents re-entry loops
- [ ] No PHP errors on page load
</success_criteria>

<output>
After completion, create `.planning/phases/1.5-automatic-speech-flow/1.5-01-SUMMARY.md`
</output>
