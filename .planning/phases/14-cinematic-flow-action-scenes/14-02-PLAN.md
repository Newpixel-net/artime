---
phase: 14-cinematic-flow-action-scenes
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - modules/AppVideoWizard/app/Livewire/VideoWizard.php
  - modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php
autonomous: true

must_haves:
  truths:
    - "Action scenes (no dialogue) produce varied shot types following action coverage pattern"
    - "Mixed scenes use speech-driven path; full hybrid handling deferred to future enhancement"
    - "Scene type detection routes to appropriate decomposition path"
  artifacts:
    - path: "modules/AppVideoWizard/app/Livewire/VideoWizard.php"
      provides: "Scene type routing in decomposeSceneWithDynamicEngine"
      contains: "detectSceneType"
    - path: "modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php"
      provides: "Action scene decomposition method"
      contains: "decomposeActionScene"
  key_links:
    - from: "VideoWizard.decomposeSceneWithDynamicEngine"
      to: "SceneTypeDetectorService.detectSceneType"
      via: "service call for classification"
      pattern: "detectSceneType"
    - from: "DialogueSceneDecomposerService.decomposeActionScene"
      to: "ShotContinuityService.getCoveragePattern"
      via: "service call for coverage pattern"
      pattern: "getCoveragePattern.*action"
---

<objective>
Add scene type routing and action scene decomposition for non-dialogue scenes

Purpose: Implement SCNE-02 (action decomposition) and partial SCNE-03 (mixed scene handling). Routes scenes through SceneTypeDetectorService and applies appropriate decomposition strategy based on scene type.

Output: Scene type routing in VideoWizard + decomposeActionScene() method for action-only scenes
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-cinematic-flow-action-scenes/14-RESEARCH.md
@.planning/phases/14-cinematic-flow-action-scenes/14-01-SUMMARY.md

# Key source files
@modules/AppVideoWizard/app/Livewire/VideoWizard.php (line 17982 decomposeSceneWithDynamicEngine)
@modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php
@modules/AppVideoWizard/app/Services/SceneTypeDetectorService.php (line 34 detectSceneType)
@modules/AppVideoWizard/app/Services/ShotContinuityService.php (COVERAGE_PATTERNS at line 44, getCoveragePattern method)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add decomposeActionScene method to DialogueSceneDecomposerService</name>
  <files>modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php</files>
  <action>
Add a public method `decomposeActionScene(array $scene, int $sceneIndex, array $context = []): array` that creates shots for non-dialogue (action) scenes.

The method should:

1. Inject or resolve ShotContinuityService to use its getCoveragePattern('action') method
2. Extract action content from scene narration
3. Break narration into "action beats" (sentences or significant phrases)
4. Apply action coverage pattern from ShotContinuityService
5. Create one shot per action beat, cycling through the pattern

Get coverage pattern from existing service (DO NOT duplicate the array):
```php
$shotContinuityService = app(\Modules\AppVideoWizard\App\Services\ShotContinuityService::class);
$actionCoveragePattern = $shotContinuityService->getCoveragePattern('action');
// Returns: ['establishing', 'wide', 'medium', 'tracking', 'close-up', 'insert']
```

For each action beat:
```php
$patternIndex = $beatIndex % count($actionCoveragePattern);
$shotType = $this->mapActionTypeToDialogueType($actionCoveragePattern[$patternIndex]);
```

Add helper method `mapActionTypeToDialogueType(string $actionType): string` that maps action pattern types to types that exist in $dialogueShotTypes:
- 'tracking' -> 'medium' with cameraMovement='tracking'
- 'insert' -> 'extreme-close-up'
- others map directly

Create shot array structure matching what enhanceShotsWithDialoguePatterns expects:
```php
[
    'type' => $shotType,
    'purpose' => $actionCoveragePattern[$patternIndex],
    'description' => $beat,
    'speaker' => null,  // No dialogue
    'dialogue' => '',
    'isActionShot' => true,
    'cameraMovement' => $this->getCameraMovementForActionType($actionType),
]
```

Add helper method `extractActionBeats(string $narration): array` that splits narration into meaningful action chunks (by sentence, semicolon, or "and then" patterns).

Log summary: action beats found, shots created.
  </action>
  <verify>
Grep for "decomposeActionScene" confirms method exists.
Grep for "getCoveragePattern.*action" confirms ShotContinuityService is used for pattern.
Grep for "isActionShot" confirms action shot flag is set.
  </verify>
  <done>Action scenes produce varied shot types (establishing, wide, medium, tracking, close-up, insert) using ShotContinuityService's coverage pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Add scene type detection and routing in VideoWizard</name>
  <files>modules/AppVideoWizard/app/Livewire/VideoWizard.php</files>
  <action>
Modify `decomposeSceneWithDynamicEngine()` to add scene type detection BEFORE the current dialogue/speech checks.

At the start of the method (after $sceneId assignment, around line 17984), add:

```php
// Phase 14: Detect scene type for appropriate routing
$sceneTypeDetector = app(\Modules\AppVideoWizard\App\Services\SceneTypeDetectorService::class);
$sceneTypeResult = $sceneTypeDetector->detectSceneType($scene, [
    'sceneIndex' => $sceneIndex,
    'totalScenes' => count($this->script['scenes'] ?? []),
]);
$sceneType = $sceneTypeResult['sceneType'] ?? 'dialogue';

Log::debug('VideoWizard: Scene type detected', [
    'scene_id' => $sceneId,
    'scene_type' => $sceneType,
    'confidence' => $sceneTypeResult['confidence'] ?? 0,
]);
```

Then modify the existing flow to use this detection:

1. If sceneType is 'action' AND no lipSyncSegments: Route to new action decomposition
2. If sceneType is 'mixed': Use speech-driven path (same as dialogue - speech segments drive shots)
3. Otherwise: Continue with existing speech-driven/dialogue flow

Insert new action routing AFTER the speech-driven block (around line 18045) but BEFORE the dialogue fallback:

```php
// Phase 14: ACTION SCENE DECOMPOSITION (SCNE-02)
// If scene is action type and has no speech, use action coverage pattern
if ($sceneType === 'action' && empty($lipSyncSegments)) {
    Log::info('VideoWizard: Action scene detected, using action coverage pattern', [
        'scene_id' => $sceneId,
        'scene_index' => $sceneIndex,
    ]);

    $actionShots = $dialogueDecomposer->decomposeActionScene($scene, $sceneIndex, [
        'visualDescription' => $visualDescription,
        'characterBible' => $this->sceneMemory['characterBible'] ?? [],
    ]);

    if (!empty($actionShots)) {
        // Convert to standard format and return
        $shots = $this->convertDialogueShotsToStandardFormat(
            $actionShots,
            $sceneId,
            $scene,
            $visualDescription
        );

        Log::info('VideoWizard: Action scene decomposed', [
            'scene_id' => $sceneId,
            'shots_created' => count($shots),
            'path' => 'action-coverage',
        ]);

        return $shots;
    }
}
```

For mixed scenes (SCNE-03), the existing dialogue path handles the speech portions. Add a comment noting this:
```php
// Phase 14: Mixed scenes (SCNE-03) are handled by the speech-driven path above.
// Speech segments create dialogue shots; remaining scene content flows to standard decomposition.
// Full hybrid handling (interleaving dialogue and action beats) deferred to future enhancement.
```
  </action>
  <verify>
Grep for "detectSceneType" in VideoWizard confirms integration.
Grep for "action-coverage" confirms action path logging.
Grep for "SCNE-02" or "Action scene detected" confirms action routing exists.
  </verify>
  <done>Scene type detection routes action scenes to decomposeActionScene, mixed scenes use speech-driven path, dialogue scenes continue unchanged.</done>
</task>

<task type="auto">
  <name>Task 3: Add visual prompt continuity helper</name>
  <files>modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php</files>
  <action>
Add a protected method `ensureVisualContinuity(array $shots, array $scene): array` that verifies visual prompt elements are consistent across the shot sequence.

Visual continuity means:
1. Character descriptions remain consistent (same clothing, hair, etc.)
2. Location/setting persists across shots
3. Props mentioned early remain available in later shots
4. Lighting/time-of-day is consistent

The method should:
1. Extract key visual elements from scene (location, time, weather, props)
2. For each shot, check that its description doesn't contradict scene elements
3. If shot description is empty or generic, enhance with scene context
4. Add continuity metadata to shots

```php
protected function ensureVisualContinuity(array $shots, array $scene): array
{
    $sceneContext = [
        'location' => $this->extractLocation($scene['narration'] ?? ''),
        'timeOfDay' => $this->extractTimeOfDay($scene['narration'] ?? ''),
        'weather' => $this->extractWeather($scene['narration'] ?? ''),
    ];

    foreach ($shots as &$shot) {
        // Add scene context to each shot for prompt building
        $shot['sceneContext'] = $sceneContext;

        // Flag for downstream prompt builders
        $shot['visualContinuityApplied'] = true;
    }

    Log::debug('DialogueDecomposer: Visual continuity applied', [
        'shot_count' => count($shots),
        'context' => $sceneContext,
    ]);

    return $shots;
}
```

Add simple extraction helpers:
- `extractLocation(string $text): ?string` - looks for "in the", "at the", location keywords
- `extractTimeOfDay(string $text): ?string` - looks for morning/afternoon/evening/night/dawn/dusk
- `extractWeather(string $text): ?string` - looks for rain/sun/storm/fog/snow

Call this method at the end of both `enhanceShotsWithDialoguePatterns()` and `decomposeActionScene()` before returning.

IMPORTANT: In `enhanceShotsWithDialoguePatterns()`, this call must come AFTER the `validateAndFixTransitions()` call added by Plan 14-01:
```php
// Phase 14: Validate and fix transitions (FLOW-03) - added by Plan 14-01
$shots = $this->validateAndFixTransitions($shots);

// Phase 14: Ensure visual continuity across shots - added by Plan 14-02
$shots = $this->ensureVisualContinuity($shots, $scene);
```
  </action>
  <verify>
Grep for "ensureVisualContinuity" confirms method exists.
Grep for "visualContinuityApplied" confirms flag is being set on shots.
Grep for "sceneContext" confirms context is attached to shots.
  </verify>
  <done>Visual prompt continuity verified across shot sequences - consistent location, time, weather metadata attached to each shot.</done>
</task>

</tasks>

<verification>
1. Scene type detection integrated: grep "detectSceneType" in VideoWizard.php
2. Action decomposition exists: grep "decomposeActionScene" in DialogueSceneDecomposerService.php
3. Uses ShotContinuityService for pattern: grep "getCoveragePattern.*action" in DialogueSceneDecomposerService.php
4. Visual continuity helper exists: grep "ensureVisualContinuity" in DialogueSceneDecomposerService.php
5. Routing logs exist: grep "action-coverage" or "Action scene detected" in VideoWizard.php
</verification>

<success_criteria>
1. Action scenes (no dialogue) route to decomposeActionScene and produce varied shot types
2. Shot types follow Hollywood action coverage pattern from ShotContinuityService (establishing -> wide -> medium -> tracking -> close-up -> insert)
3. Scene type is detected and logged for debugging
4. Visual prompt continuity metadata attached to all shots
5. Mixed scenes use speech-driven path (full hybrid handling deferred to future enhancement)
</success_criteria>

<output>
After completion, create `.planning/phases/14-cinematic-flow-action-scenes/14-02-SUMMARY.md`
</output>
