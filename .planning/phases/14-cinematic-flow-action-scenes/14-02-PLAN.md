---
phase: 14-cinematic-flow-action-scenes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - modules/AppVideoWizard/app/Livewire/VideoWizard.php
  - modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php
autonomous: true

must_haves:
  truths:
    - "Action scenes (no dialogue) produce varied shot types following action coverage pattern"
    - "Mixed scenes (dialogue + action) handled with smooth mode transitions"
    - "Scene type detection routes to appropriate decomposition path"
  artifacts:
    - path: "modules/AppVideoWizard/app/Livewire/VideoWizard.php"
      provides: "Scene type routing in decomposeSceneWithDynamicEngine"
      contains: "detectSceneType"
    - path: "modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php"
      provides: "Action scene decomposition method"
      contains: "decomposeActionScene"
  key_links:
    - from: "VideoWizard.decomposeSceneWithDynamicEngine"
      to: "SceneTypeDetectorService.detectSceneType"
      via: "service call for classification"
      pattern: "detectSceneType"
    - from: "DialogueSceneDecomposerService.decomposeActionScene"
      to: "COVERAGE_PATTERNS action"
      via: "coverage pattern application"
      pattern: "establishing.*wide.*medium"
---

<objective>
Add scene type routing and action scene decomposition for non-dialogue scenes

Purpose: Implement SCNE-02 (action decomposition) and SCNE-03 (mixed scene handling). Routes scenes through SceneTypeDetectorService and applies appropriate decomposition strategy based on scene type.

Output: Scene type routing in VideoWizard + decomposeActionScene() method for action-only scenes
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-cinematic-flow-action-scenes/14-RESEARCH.md

# Key source files
@modules/AppVideoWizard/app/Livewire/VideoWizard.php (line 17982 decomposeSceneWithDynamicEngine)
@modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php
@modules/AppVideoWizard/app/Services/SceneTypeDetectorService.php (line 34 detectSceneType)
@modules/AppVideoWizard/app/Services/ShotContinuityService.php (COVERAGE_PATTERNS at line 44)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add decomposeActionScene method to DialogueSceneDecomposerService</name>
  <files>modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php</files>
  <action>
Add a public method `decomposeActionScene(array $scene, int $sceneIndex, array $context = []): array` that creates shots for non-dialogue (action) scenes.

The method should:

1. Extract action content from scene narration
2. Break narration into "action beats" (sentences or significant phrases)
3. Apply action coverage pattern: establishing -> wide -> medium -> tracking -> close-up -> insert
4. Create one shot per action beat, cycling through the pattern

Coverage pattern (from ShotContinuityService.COVERAGE_PATTERNS['action']):
```php
protected array $actionCoveragePattern = [
    'establishing',  // Sets location (shot 1, then every 6th)
    'wide',          // Full action context
    'medium',        // Character action
    'tracking',      // Following movement (map to medium-wide with movement)
    'close-up',      // Detail/impact
    'insert',        // Specific detail (map to extreme-close-up)
];
```

For each action beat:
```php
$patternIndex = $beatIndex % count($actionCoveragePattern);
$shotType = $this->mapActionTypeToDialogueType($actionCoveragePattern[$patternIndex]);
```

Add helper method `mapActionTypeToDialogueType(string $actionType): string` that maps action pattern types to types that exist in $dialogueShotTypes:
- 'tracking' -> 'medium' with cameraMovement='tracking'
- 'insert' -> 'extreme-close-up'
- others map directly

Create shot array structure matching what enhanceShotsWithDialoguePatterns expects:
```php
[
    'type' => $shotType,
    'purpose' => $actionCoveragePattern[$patternIndex],
    'description' => $beat,
    'speaker' => null,  // No dialogue
    'dialogue' => '',
    'isActionShot' => true,
    'cameraMovement' => $this->getCameraMovementForActionType($actionType),
]
```

Add helper method `extractActionBeats(string $narration): array` that splits narration into meaningful action chunks (by sentence, semicolon, or "and then" patterns).

Log summary: action beats found, shots created.
  </action>
  <verify>
Grep for "decomposeActionScene" confirms method exists.
Grep for "actionCoveragePattern" confirms pattern is defined.
Grep for "isActionShot" confirms action shot flag is set.
  </verify>
  <done>Action scenes produce varied shot types (establishing, wide, medium, tracking, close-up, insert) following Hollywood action coverage pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Add scene type detection and routing in VideoWizard</name>
  <files>modules/AppVideoWizard/app/Livewire/VideoWizard.php</files>
  <action>
Modify `decomposeSceneWithDynamicEngine()` to add scene type detection BEFORE the current dialogue/speech checks.

At the start of the method (after $sceneId assignment, around line 17984), add:

```php
// Phase 14: Detect scene type for appropriate routing
$sceneTypeDetector = app(\Modules\AppVideoWizard\App\Services\SceneTypeDetectorService::class);
$sceneTypeResult = $sceneTypeDetector->detectSceneType($scene, [
    'sceneIndex' => $sceneIndex,
    'totalScenes' => count($this->script['scenes'] ?? []),
]);
$sceneType = $sceneTypeResult['sceneType'] ?? 'dialogue';

Log::debug('VideoWizard: Scene type detected', [
    'scene_id' => $sceneId,
    'scene_type' => $sceneType,
    'confidence' => $sceneTypeResult['confidence'] ?? 0,
]);
```

Then modify the existing flow to use this detection:

1. If sceneType is 'action' AND no lipSyncSegments: Route to new action decomposition
2. If sceneType is 'mixed': Use hybrid approach (dialogue path with action fallback for non-speech portions)
3. Otherwise: Continue with existing speech-driven/dialogue flow

Insert new action routing AFTER the speech-driven block (around line 18045) but BEFORE the dialogue fallback:

```php
// Phase 14: ACTION SCENE DECOMPOSITION (SCNE-02)
// If scene is action type and has no speech, use action coverage pattern
if ($sceneType === 'action' && empty($lipSyncSegments)) {
    Log::info('VideoWizard: Action scene detected, using action coverage pattern', [
        'scene_id' => $sceneId,
        'scene_index' => $sceneIndex,
    ]);

    $actionShots = $dialogueDecomposer->decomposeActionScene($scene, $sceneIndex, [
        'visualDescription' => $visualDescription,
        'characterBible' => $this->sceneMemory['characterBible'] ?? [],
    ]);

    if (!empty($actionShots)) {
        // Convert to standard format and return
        $shots = $this->convertDialogueShotsToStandardFormat(
            $actionShots,
            $sceneId,
            $scene,
            $visualDescription
        );

        Log::info('VideoWizard: Action scene decomposed', [
            'scene_id' => $sceneId,
            'shots_created' => count($shots),
            'path' => 'action-coverage',
        ]);

        return $shots;
    }
}
```

For mixed scenes (SCNE-03), the existing dialogue path handles the speech portions. Add a comment noting this:
```php
// Phase 14: Mixed scenes (SCNE-03) are handled by the speech-driven path above.
// Speech segments create dialogue shots; remaining scene content flows to standard decomposition.
// Future enhancement: Could segment scene into dialogue/action beats and route each separately.
```
  </action>
  <verify>
Grep for "detectSceneType" in VideoWizard confirms integration.
Grep for "action-coverage" confirms action path logging.
Grep for "SCNE-02" or "Action scene detected" confirms action routing exists.
  </verify>
  <done>Scene type detection routes action scenes to decomposeActionScene, mixed scenes use speech-driven path, dialogue scenes continue unchanged.</done>
</task>

<task type="auto">
  <name>Task 3: Add visual prompt continuity helper</name>
  <files>modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php</files>
  <action>
Add a protected method `ensureVisualContinuity(array $shots, array $scene): array` that verifies visual prompt elements are consistent across the shot sequence.

Visual continuity means:
1. Character descriptions remain consistent (same clothing, hair, etc.)
2. Location/setting persists across shots
3. Props mentioned early remain available in later shots
4. Lighting/time-of-day is consistent

The method should:
1. Extract key visual elements from scene (location, time, weather, props)
2. For each shot, check that its description doesn't contradict scene elements
3. If shot description is empty or generic, enhance with scene context
4. Add continuity metadata to shots

```php
protected function ensureVisualContinuity(array $shots, array $scene): array
{
    $sceneContext = [
        'location' => $this->extractLocation($scene['narration'] ?? ''),
        'timeOfDay' => $this->extractTimeOfDay($scene['narration'] ?? ''),
        'weather' => $this->extractWeather($scene['narration'] ?? ''),
    ];

    foreach ($shots as &$shot) {
        // Add scene context to each shot for prompt building
        $shot['sceneContext'] = $sceneContext;

        // Flag for downstream prompt builders
        $shot['visualContinuityApplied'] = true;
    }

    Log::debug('DialogueDecomposer: Visual continuity applied', [
        'shot_count' => count($shots),
        'context' => $sceneContext,
    ]);

    return $shots;
}
```

Add simple extraction helpers:
- `extractLocation(string $text): ?string` - looks for "in the", "at the", location keywords
- `extractTimeOfDay(string $text): ?string` - looks for morning/afternoon/evening/night/dawn/dusk
- `extractWeather(string $text): ?string` - looks for rain/sun/storm/fog/snow

Call this method at the end of both `enhanceShotsWithDialoguePatterns()` and `decomposeActionScene()` before returning:
```php
$shots = $this->ensureVisualContinuity($shots, $scene);
```
  </action>
  <verify>
Grep for "ensureVisualContinuity" confirms method exists.
Grep for "visualContinuityApplied" confirms flag is being set on shots.
Grep for "sceneContext" confirms context is attached to shots.
  </verify>
  <done>Visual prompt continuity verified across shot sequences - consistent location, time, weather metadata attached to each shot.</done>
</task>

</tasks>

<verification>
1. Scene type detection integrated: grep "detectSceneType" in VideoWizard.php
2. Action decomposition exists: grep "decomposeActionScene" in DialogueSceneDecomposerService.php
3. Action coverage pattern applied: grep "actionCoveragePattern" or "establishing.*wide" in DialogueSceneDecomposerService.php
4. Visual continuity helper exists: grep "ensureVisualContinuity" in DialogueSceneDecomposerService.php
5. Routing logs exist: grep "action-coverage" or "Action scene detected" in VideoWizard.php
</verification>

<success_criteria>
1. Action scenes (no dialogue) route to decomposeActionScene and produce varied shot types
2. Shot types follow Hollywood action coverage pattern (establishing -> wide -> medium -> tracking -> close-up -> insert)
3. Scene type is detected and logged for debugging
4. Visual prompt continuity metadata attached to all shots
5. Mixed scenes handled by existing speech-driven path (no special routing needed - speech segments drive shots)
</success_criteria>

<output>
After completion, create `.planning/phases/14-cinematic-flow-action-scenes/14-02-SUMMARY.md`
</output>
