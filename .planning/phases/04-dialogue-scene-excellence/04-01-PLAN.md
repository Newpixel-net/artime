---
phase: 04-dialogue-scene-excellence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Camera position is tracked per shot (left/right of axis)"
    - "180-degree rule is enforced across dialogue shots"
    - "Reverse shots are explicitly paired"
    - "Eye-line direction is specified in shot data"
  artifacts:
    - path: "modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php"
      provides: "Spatial continuity tracking for dialogue shots"
      contains: "cameraPosition"
  key_links:
    - from: "DialogueSceneDecomposerService.php"
      to: "shot generation"
      via: "cameraPosition and eyeLine tracking"
      pattern: "cameraPosition"
---

<objective>
Add spatial continuity tracking to dialogue shots for proper Shot/Reverse-Shot.

**PROBLEM:** Current system generates individual shots without spatial relationship:
- No camera position tracking (left/right of axis)
- No 180-degree rule enforcement
- Reverse shots not explicitly paired
- Eye-lines not specified - characters may look past each other

Purpose: Ensure dialogue shots have proper spatial relationships like professional Hollywood productions.

Output: Every dialogue shot includes camera position, eye-line direction, and reverse-shot pairing.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add spatial tracking properties to shot structure</name>
  <files>modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php</files>
  <action>
Find the shot generation section and enhance each shot with spatial data. Add these fields to every shot:

```php
// Spatial continuity data for Hollywood-standard coverage
'spatial' => [
    'cameraPosition' => 'left',     // 'left' or 'right' of the axis
    'cameraAngle' => 'three-quarter', // 'profile', 'three-quarter', 'frontal'
    'subjectPosition' => 'right',   // Where subject appears in frame
    'eyeLineDirection' => 'left',   // Direction character is looking
    'reverseOf' => null,            // Shot index this is reverse of
    'pairId' => 'pair_1',           // Identifies matched shot pairs
],
```

Add a constant for the 180-degree axis:

```php
/**
 * PHASE 4: 180-degree rule - camera stays on one side of the action line.
 * The axis is an imaginary line between the two characters.
 */
protected string $axisLockSide = 'left'; // Camera stays on left side of axis
```

WHY: Spatial data enables consistent eye-lines and proper reverse shots.
  </action>
  <verify>
    - Shots include 'spatial' array with cameraPosition
    - $axisLockSide property exists
    - No PHP syntax errors
  </verify>
  <done>Spatial tracking properties added to shot structure</done>
</task>

<task type="auto">
  <name>Task 2: Implement camera position assignment for dialogue pattern</name>
  <files>modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php</files>
  <action>
Add a method to calculate camera position based on speaker and maintain 180-degree rule:

```php
/**
 * PHASE 4: Calculate camera position for dialogue shot.
 * Maintains 180-degree rule - camera stays on same side of axis.
 *
 * @param string $speakerName Current speaker
 * @param array $characters Array of [characterA, characterB]
 * @param string $shotType Type of shot (establishing, ots, close-up, etc.)
 * @return array Spatial data for the shot
 */
protected function calculateSpatialData(string $speakerName, array $characters, string $shotType): array
{
    // Determine which character is speaking (A or B)
    $isCharacterA = strcasecmp($speakerName, $characters[0]) === 0;

    // Camera position follows 180-degree rule
    // When shooting Character A: camera is on left, A is screen-right, looks screen-left
    // When shooting Character B: camera is on left, B is screen-left, looks screen-right

    $spatial = [
        'cameraPosition' => $this->axisLockSide, // Always same side (180-degree rule)
        'cameraAngle' => $this->determineCameraAngle($shotType),
        'subjectPosition' => $isCharacterA ? 'right' : 'left', // A=right, B=left
        'eyeLineDirection' => $isCharacterA ? 'screen-left' : 'screen-right',
        'lookingAt' => $isCharacterA ? $characters[1] : $characters[0],
        'reverseOf' => null, // Set later when pairing
        'pairId' => null,    // Set later when pairing
    ];

    return $spatial;
}

/**
 * Determine camera angle based on shot type.
 */
protected function determineCameraAngle(string $shotType): string
{
    return match($shotType) {
        'establishing', 'two-shot', 'wide' => 'frontal',
        'over-the-shoulder' => 'three-quarter',
        'medium', 'medium-close' => 'three-quarter',
        'close-up', 'extreme-close-up' => 'profile',
        default => 'three-quarter',
    };
}
```

WHY: This ensures all shots respect the 180-degree rule automatically.
  </action>
  <verify>
    - `calculateSpatialData()` method exists
    - Returns camera position based on speaker
    - Eye-line direction is opposite of subject position
    - `determineCameraAngle()` method exists
    - No PHP syntax errors
  </verify>
  <done>Camera position assignment implemented</done>
</task>

<task type="auto">
  <name>Task 3: Add reverse shot pairing system</name>
  <files>modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php</files>
  <action>
Add a method to pair reverse shots after generation:

```php
/**
 * PHASE 4: Pair reverse shots in the dialogue sequence.
 * Links shots that form shot/reverse-shot pairs.
 *
 * @param array $shots Array of shots to process
 * @return array Shots with reverse pairing data
 */
protected function pairReverseShots(array $shots): array
{
    $pairCounter = 0;
    $lastSpeakerShot = [];

    foreach ($shots as $index => &$shot) {
        // Skip non-dialogue shots (establishing, reaction without speaker)
        if (empty($shot['speakingCharacter'])) {
            continue;
        }

        $speaker = $shot['speakingCharacter'];

        // Check if there's a previous shot from different speaker (reverse candidate)
        foreach ($lastSpeakerShot as $prevSpeaker => $prevIndex) {
            if ($prevSpeaker !== $speaker && $prevIndex !== null) {
                // This is a reverse of the previous speaker's shot
                $pairId = 'pair_' . $pairCounter;

                // Link current shot to previous
                $shot['spatial']['reverseOf'] = $prevIndex;
                $shot['spatial']['pairId'] = $pairId;

                // Link previous shot to current
                $shots[$prevIndex]['spatial']['pairId'] = $pairId;

                $pairCounter++;
                break;
            }
        }

        // Track this speaker's latest shot
        $lastSpeakerShot[$speaker] = $index;
    }

    return $shots;
}
```

Then integrate this into the main decomposition method:

```php
// After generating all shots, pair the reverse shots
$shots = $this->pairReverseShots($shots);
```

WHY: Explicit pairing allows validation and consistent framing between reverse shots.
  </action>
  <verify>
    - `pairReverseShots()` method exists
    - Shots get `pairId` when they form reverse pairs
    - `reverseOf` links back to the paired shot
    - Method is called in main decomposition flow
    - No PHP syntax errors
  </verify>
  <done>Reverse shot pairing system implemented</done>
</task>

<task type="auto">
  <name>Task 4: Enhance visual prompts with spatial information</name>
  <files>modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php</files>
  <action>
Update the visual prompt generation to include spatial information:

```php
/**
 * PHASE 4: Build visual prompt with spatial continuity information.
 *
 * @param array $shot Shot data including spatial info
 * @param array $characterData Character appearance data
 * @return string Enhanced visual prompt
 */
protected function buildSpatialAwarePrompt(array $shot, array $characterData): string
{
    $prompt = [];

    // Base character description
    $characterName = $shot['speakingCharacter'] ?? 'character';
    $appearance = $characterData['appearance'] ?? '';

    // Shot type and framing
    $shotType = $shot['type'] ?? 'medium';
    $prompt[] = ucfirst($shotType) . ' shot of ' . $characterName;

    if (!empty($appearance)) {
        $prompt[] = "({$appearance})";
    }

    // PHASE 4: Add spatial positioning
    $spatial = $shot['spatial'] ?? [];

    if (!empty($spatial['subjectPosition'])) {
        $prompt[] = "positioned {$spatial['subjectPosition']} of frame";
    }

    if (!empty($spatial['eyeLineDirection'])) {
        $prompt[] = "looking {$spatial['eyeLineDirection']}";
    }

    if (!empty($spatial['cameraAngle'])) {
        $angleDesc = match($spatial['cameraAngle']) {
            'profile' => 'in profile view',
            'three-quarter' => 'at three-quarter angle',
            'frontal' => 'facing camera',
            default => '',
        };
        if ($angleDesc) {
            $prompt[] = $angleDesc;
        }
    }

    // Add expression based on dialogue
    if (!empty($shot['expression'])) {
        $prompt[] = "with {$shot['expression']} expression";
    }

    // Add dialogue context
    if (!empty($shot['dialogue'])) {
        $dialogueHint = $this->getDialogueVisualHint($shot['dialogue']);
        if ($dialogueHint) {
            $prompt[] = $dialogueHint;
        }
    }

    return implode(', ', array_filter($prompt)) . '.';
}

/**
 * Get visual hint from dialogue content.
 */
protected function getDialogueVisualHint(string $dialogue): string
{
    if (str_ends_with(trim($dialogue), '?')) {
        return 'questioning expression';
    }
    if (str_ends_with(trim($dialogue), '!')) {
        return 'emphatic delivery';
    }
    if (stripos($dialogue, 'sorry') !== false || stripos($dialogue, 'apologize') !== false) {
        return 'apologetic demeanor';
    }
    if (stripos($dialogue, 'love') !== false || stripos($dialogue, 'care') !== false) {
        return 'warm expression';
    }
    return '';
}
```

WHY: Spatial information in prompts helps AI generate properly framed shots.
  </action>
  <verify>
    - `buildSpatialAwarePrompt()` method exists
    - Prompt includes subject position (left/right of frame)
    - Prompt includes eye-line direction
    - Prompt includes camera angle description
    - No PHP syntax errors
  </verify>
  <done>Visual prompts enhanced with spatial information</done>
</task>

<task type="auto">
  <name>Task 5: Integrate spatial tracking into main decomposition</name>
  <files>modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php</files>
  <action>
Update the main `decomposeDialogueScene()` method to use spatial tracking:

1. Find where shots are created for dialogue exchanges
2. Add spatial data calculation for each shot
3. Use the spatial-aware prompt builder
4. Call reverse shot pairing at the end

Look for the loop that creates speaking shots and add:

```php
// PHASE 4: Calculate spatial data for this shot
$characters = array_keys($characterLookup);
$spatial = $this->calculateSpatialData(
    $exchange['speaker'],
    array_slice($characters, 0, 2), // First two characters
    $shotType
);

$shot['spatial'] = $spatial;

// Use spatial-aware prompt
$shot['visualDescription'] = $this->buildSpatialAwarePrompt($shot, $characterData);
```

At the end of the method, before returning:

```php
// PHASE 4: Pair reverse shots for continuity validation
$shots = $this->pairReverseShots($shots);

Log::info('DialogueSceneDecomposer: Generated shots with spatial continuity', [
    'shot_count' => count($shots),
    'pair_count' => count(array_filter($shots, fn($s) => !empty($s['spatial']['pairId']))),
]);
```

WHY: This connects all the spatial tracking components together.
  </action>
  <verify>
    - `decomposeDialogueScene()` calls `calculateSpatialData()` for each shot
    - `decomposeDialogueScene()` calls `buildSpatialAwarePrompt()`
    - `decomposeDialogueScene()` calls `pairReverseShots()` before returning
    - Log message shows pair count
    - No PHP syntax errors: `php -l modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php`
  </verify>
  <done>Spatial tracking integrated into main decomposition flow</done>
</task>

</tasks>

<verification>
1. PHP syntax check: `php -l modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php`
2. Grep for spatial methods:
   - `grep -n "calculateSpatialData" modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php`
   - `grep -n "pairReverseShots" modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php`
   - `grep -n "cameraPosition" modules/AppVideoWizard/app/Services/DialogueSceneDecomposerService.php`
</verification>

<success_criteria>
- Every dialogue shot has spatial data (cameraPosition, eyeLineDirection, subjectPosition)
- 180-degree rule enforced (camera stays on same side of axis)
- Reverse shots are explicitly paired with pairId
- Visual prompts include positioning information
- PHP syntax valid
</success_criteria>

<output>
After completion, create `.planning/phases/04-dialogue-scene-excellence/04-01-SUMMARY.md`
</output>
