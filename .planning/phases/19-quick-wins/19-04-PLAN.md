---
phase: 19-quick-wins
plan: 04
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - modules/AppVideoWizard/app/Livewire/VideoWizard.php
autonomous: true
user_setup: []

must_haves:
  truths:
    - "updated() hook does not process every property change"
    - "Only specific property changes trigger necessary side effects"
    - "buildSceneDNA() is not called on every update"
    - "Modal open state skips updated() processing efficiently"
  artifacts:
    - path: "modules/AppVideoWizard/app/Livewire/VideoWizard.php"
      provides: "Optimized updated() hook implementation"
      contains: "updatedScriptScenes"
  key_links:
    - from: "VideoWizard updated() hook"
      to: "buildSceneDNA()"
      via: "Targeted property watchers"
      pattern: "updated[A-Z]"
---

<objective>
Refactor the updated() hook from a generic catch-all to targeted property-specific methods for efficient change handling.

Purpose: The current updated() hook catches ALL property changes, uses regex matching, and calls buildSceneDNA() on Bible changes. This adds overhead to every Livewire request. Livewire 3 supports targeted updatedPropertyName() methods that only fire for specific properties.

Output: VideoWizard.php with optimized property change handling using targeted update methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@modules/AppVideoWizard/app/Livewire/VideoWizard.php
</context>

<tasks>

<task type="auto">
  <name>Task 1: Analyze and document current updated() behavior</name>
  <files>modules/AppVideoWizard/app/Livewire/VideoWizard.php</files>
  <action>
Read the current updated() method (around line 1908) and document what it does:

Current behavior:
1. Returns early if `$isBatchUpdating` is true
2. Regex matches `script.scenes.{N}.narration` -> calls parseSceneNarration()
3. Returns early if modal is open (showCharacterBibleModal || showLocationBibleModal)
4. Checks if property starts with trigger properties (sceneMemory.characterBible, etc.)
5. If trigger matches and >2 seconds since last sync, calls buildSceneDNA()

Problems:
- Regex executed on EVERY property change
- Multiple str_starts_with() checks on every change
- Even non-trigger properties go through all checks

Document which properties ACTUALLY need updated() handling:
1. `script.scenes.{N}.narration` -> parseSceneNarration($sceneIndex)
2. `sceneMemory.characterBible.*` -> buildSceneDNA() (debounced)
3. `sceneMemory.locationBible.*` -> buildSceneDNA() (debounced)
4. `sceneMemory.styleBible.*` -> buildSceneDNA() (debounced)
5. `script.scenes.*` -> buildSceneDNA() (debounced)
  </action>
  <verify>
Confirm the current updated() implementation by reading lines 1908-1960:
```bash
sed -n '1908,1960p' modules/AppVideoWizard/app/Livewire/VideoWizard.php
```
  </verify>
  <done>Current updated() behavior documented, showing regex and multiple conditional checks on every property change.</done>
</task>

<task type="auto">
  <name>Task 2: Implement targeted update methods</name>
  <files>modules/AppVideoWizard/app/Livewire/VideoWizard.php</files>
  <action>
Livewire 3 supports targeted update methods: `updated{PropertyName}($value)` which only fire when that specific property changes.

For nested properties like `script.scenes.0.narration`, use: `updatedScriptScenes($value, $key)` where $key contains the nested path.

**Step 1: Create targeted methods for each concern**

```php
/**
 * Handle script.scenes changes - triggers Scene DNA rebuild.
 * Livewire calls this for any change to script.scenes.*
 */
public function updatedScriptScenes($value, $key): void
{
    // Skip during batch operations
    if ($this->isBatchUpdating) {
        return;
    }

    // Check if this is a narration change (e.g., "0.narration")
    if (preg_match('/^(\d+)\.narration$/', $key, $matches)) {
        if (!$this->isParsing) {
            $sceneIndex = (int) $matches[1];
            $this->parseSceneNarration($sceneIndex);
        }
        return;
    }

    // Other scene changes trigger DNA rebuild (debounced)
    $this->debouncedBuildSceneDNA();
}

/**
 * Handle sceneMemory.characterBible changes - triggers Scene DNA rebuild.
 */
public function updatedSceneMemoryCharacterBible($value, $key): void
{
    if ($this->isBatchUpdating) {
        return;
    }

    // Skip if modal is open (will rebuild on close)
    if ($this->showCharacterBibleModal) {
        return;
    }

    $this->debouncedBuildSceneDNA();
}

/**
 * Handle sceneMemory.locationBible changes - triggers Scene DNA rebuild.
 */
public function updatedSceneMemoryLocationBible($value, $key): void
{
    if ($this->isBatchUpdating) {
        return;
    }

    // Skip if modal is open (will rebuild on close)
    if ($this->showLocationBibleModal) {
        return;
    }

    $this->debouncedBuildSceneDNA();
}

/**
 * Handle sceneMemory.styleBible changes - triggers Scene DNA rebuild.
 */
public function updatedSceneMemoryStyleBible($value, $key): void
{
    if ($this->isBatchUpdating) {
        return;
    }

    $this->debouncedBuildSceneDNA();
}

/**
 * Debounced Scene DNA rebuild - prevents multiple rebuilds in quick succession.
 */
protected function debouncedBuildSceneDNA(): void
{
    // Check autoSync setting
    if (!($this->sceneMemory['sceneDNA']['autoSync'] ?? true)) {
        return;
    }

    // Debounce by checking last sync time (2 second threshold)
    $lastSync = $this->sceneMemory['sceneDNA']['lastSyncedAt'] ?? null;
    if ($lastSync && now()->diffInSeconds($lastSync) < 2) {
        return;
    }

    // Only rebuild if we have scenes
    if (!empty($this->script['scenes'])) {
        $this->buildSceneDNA();
    }
}
```

**Step 2: Simplify the generic updated() method**

The generic updated() can now be minimal or removed entirely:

```php
/**
 * Generic updated hook - now minimal since targeted methods handle specific properties.
 */
public function updated($property, $value): void
{
    // Most handling is now in targeted update{PropertyName} methods.
    // This generic hook only catches properties not handled by targeted methods.

    // Skip during batch operations
    if ($this->isBatchUpdating) {
        return;
    }

    // No action needed for most properties - targeted methods handle specific cases
}
```

Or remove it entirely if all cases are covered by targeted methods.

**Step 3: Note on Livewire 3 nested property syntax**

For nested arrays in Livewire 3:
- `$this->script['scenes'][0]['narration']` change calls `updatedScriptScenes($value, '0.narration')`
- The second parameter `$key` contains the nested path after the base property

Method naming:
- `updatedScriptScenes` for `script.scenes.*`
- `updatedSceneMemoryCharacterBible` for `sceneMemory.characterBible.*`
- Use camelCase of the dot-notation path
  </action>
  <verify>
1. Check that targeted methods exist:
```bash
grep -n "public function updated[A-Z]" modules/AppVideoWizard/app/Livewire/VideoWizard.php
```
Should show updatedScriptScenes, updatedSceneMemoryCharacterBible, updatedSceneMemoryLocationBible, updatedSceneMemoryStyleBible.

2. Check that generic updated() is minimal:
```bash
grep -A 20 "public function updated\(\$property" modules/AppVideoWizard/app/Livewire/VideoWizard.php
```
Should show a simplified implementation.

3. Verify no syntax errors:
```bash
php -l modules/AppVideoWizard/app/Livewire/VideoWizard.php
```
  </verify>
  <done>Targeted update methods replace generic updated() hook. updatedScriptScenes(), updatedSceneMemoryCharacterBible(), updatedSceneMemoryLocationBible(), updatedSceneMemoryStyleBible() handle specific property changes. Generic updated() is minimal.</done>
</task>

</tasks>

<verification>
After both tasks:
1. Load Video Wizard and open Character Bible modal
2. Edit a character name - observe that buildSceneDNA() is NOT called (modal is open)
3. Close the modal - buildSceneDNA() should be called
4. Edit script scene narration - parseSceneNarration() should be called
5. All wizard functionality still works correctly
6. Performance improvement: random property changes (like UI state) don't trigger Bible/DNA processing
</verification>

<success_criteria>
1. Targeted update methods exist: updatedScriptScenes, updatedSceneMemoryCharacterBible, updatedSceneMemoryLocationBible, updatedSceneMemoryStyleBible
2. Generic updated() is minimal or removed
3. Narration changes still trigger parseSceneNarration()
4. Bible changes still trigger buildSceneDNA() (when modal closed, debounced)
5. Non-related property changes do NOT trigger any heavy processing
6. All wizard functionality works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/19-quick-wins/19-04-SUMMARY.md`
</output>
